"""
字幕导出工具：根据台词列表和音频时长信息直接生成 SRT / ASS 字幕文件。
不依赖 ASR 识别，而是根据每条台词音频的实际时长来计算时间轴。
"""

import os
from typing import List, Optional

import soundfile as sf


def _ms_to_srt_time(ms: int) -> str:
    """毫秒 -> SRT 时间格式 HH:MM:SS,mmm"""
    total_seconds, milliseconds = divmod(int(ms), 1000)
    minutes, seconds = divmod(total_seconds, 60)
    hours, minutes = divmod(minutes, 60)
    return f"{hours:02}:{minutes:02}:{seconds:02},{milliseconds:03}"


def _ms_to_ass_time(ms: int) -> str:
    """毫秒 -> ASS 时间格式 H:MM:SS.cc"""
    total_seconds, milliseconds = divmod(int(ms), 1000)
    minutes, seconds = divmod(total_seconds, 60)
    hours, minutes = divmod(minutes, 60)
    centiseconds = int(milliseconds / 10)
    return f"{hours:01}:{minutes:02}:{seconds:02}.{centiseconds:02}"


def get_audio_duration_ms(audio_path: str) -> Optional[int]:
    """获取音频文件时长（毫秒），失败返回 None"""
    try:
        info = sf.info(audio_path)
        return int(info.frames / info.samplerate * 1000)
    except Exception:
        return None


class SubtitleSegment:
    """一条字幕片段"""

    def __init__(self, text: str, start_ms: int, end_ms: int, role_name: str = ""):
        self.text = text
        self.start_ms = start_ms
        self.end_ms = end_ms
        self.role_name = role_name


def build_subtitle_segments(
    lines_info: List[dict],
) -> List[SubtitleSegment]:
    """
    根据台词信息构建字幕片段列表。

    lines_info: [
        {
            "text": "台词文本",
            "audio_path": "/path/to/audio.wav",
            "role_name": "角色名"  # 可选
        },
        ...
    ]

    返回带时间轴的字幕片段列表。
    """
    segments = []
    cursor_ms = 0

    for info in lines_info:
        text = info.get("text", "").strip()
        audio_path = info.get("audio_path", "")
        role_name = info.get("role_name", "")

        if not text or not audio_path or not os.path.exists(audio_path):
            continue

        duration_ms = get_audio_duration_ms(audio_path)
        if duration_ms is None or duration_ms <= 0:
            continue

        start_ms = cursor_ms
        end_ms = cursor_ms + duration_ms

        segments.append(
            SubtitleSegment(
                text=text,
                start_ms=start_ms,
                end_ms=end_ms,
                role_name=role_name,
            )
        )

        cursor_ms = end_ms

    return segments


def segments_to_srt(segments: List[SubtitleSegment], include_role: bool = True) -> str:
    """将字幕片段列表转为 SRT 格式字符串"""
    lines = []
    for idx, seg in enumerate(segments, 1):
        text = seg.text
        if include_role and seg.role_name:
            text = f"[{seg.role_name}] {text}"
        lines.append(
            f"{idx}\n"
            f"{_ms_to_srt_time(seg.start_ms)} --> {_ms_to_srt_time(seg.end_ms)}\n"
            f"{text}\n"
        )
    return "\n".join(lines)


def segments_to_ass(
    segments: List[SubtitleSegment],
    include_role: bool = True,
    style_str: Optional[str] = None,
) -> str:
    """将字幕片段列表转为 ASS 格式字符串"""
    if not style_str:
        style_str = (
            "[V4+ Styles]\n"
            "Format: Name,Fontname,Fontsize,PrimaryColour,SecondaryColour,"
            "OutlineColour,BackColour,Bold,Italic,Underline,StrikeOut,"
            "ScaleX,ScaleY,Spacing,Angle,BorderStyle,Outline,Shadow,"
            "Alignment,MarginL,MarginR,MarginV,Encoding\n"
            "Style: Default,微软雅黑,56,&H00FFFFFF,&H000000FF,"
            "&H00000000,&H80000000,-1,0,0,0,100,100,"
            "0,0,1,2,1,2,10,10,20,1"
        )

    ass_content = (
        "[Script Info]\n"
        "; Script generated by HX-SayBook\n"
        "ScriptType: v4.00+\n"
        "PlayResX: 1920\n"
        "PlayResY: 1080\n"
        "WrapStyle: 0\n\n"
        f"{style_str}\n\n"
        "[Events]\n"
        "Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text\n"
    )

    for seg in segments:
        start = _ms_to_ass_time(seg.start_ms)
        end = _ms_to_ass_time(seg.end_ms)
        text = seg.text
        if include_role and seg.role_name:
            text = f"[{seg.role_name}] {text}"
        # 替换换行为 ASS 换行符
        text = text.replace("\n", "\\N")
        name = seg.role_name or ""
        ass_content += f"Dialogue: 0,{start},{end},Default,{name},0,0,0,,{text}\n"

    return ass_content


def save_subtitle(
    segments: List[SubtitleSegment],
    output_path: str,
    fmt: str = "srt",
    include_role: bool = True,
) -> str:
    """
    保存字幕文件。

    参数：
    - segments: 字幕片段列表
    - output_path: 输出路径（不含扩展名，会自动加）
    - fmt: 格式，"srt" 或 "ass"
    - include_role: 是否在字幕中显示角色名

    返回实际保存的文件路径。
    """
    if fmt == "srt":
        content = segments_to_srt(segments, include_role=include_role)
        if not output_path.endswith(".srt"):
            output_path = os.path.splitext(output_path)[0] + ".srt"
    elif fmt == "ass":
        content = segments_to_ass(segments, include_role=include_role)
        if not output_path.endswith(".ass"):
            output_path = os.path.splitext(output_path)[0] + ".ass"
    else:
        raise ValueError(f"不支持的字幕格式: {fmt}")

    os.makedirs(os.path.dirname(output_path) or ".", exist_ok=True)
    with open(output_path, "w", encoding="utf-8") as f:
        f.write(content)

    return output_path


def generate_subtitle_files(
    lines_info: List[dict],
    output_dir: str,
    base_name: str = "result",
    formats: List[str] = None,
    include_role: bool = True,
) -> dict:
    """
    一站式生成多格式字幕文件。

    参数：
    - lines_info: 台词信息列表（同 build_subtitle_segments）
    - output_dir: 输出目录
    - base_name: 输出文件基础名（不含扩展名）
    - formats: 要生成的格式列表，默认 ["srt", "ass"]
    - include_role: 是否在字幕中显示角色名

    返回：{"srt": "/path/to/file.srt", "ass": "/path/to/file.ass"}
    如果台词为空，返回空字典。
    """
    if formats is None:
        formats = ["srt", "ass"]

    segments = build_subtitle_segments(lines_info)
    if not segments:
        return {}

    os.makedirs(output_dir, exist_ok=True)
    result = {}

    for fmt in formats:
        output_path = os.path.join(output_dir, f"{base_name}.{fmt}")
        saved = save_subtitle(segments, output_path, fmt=fmt, include_role=include_role)
        result[fmt] = saved

    return result
